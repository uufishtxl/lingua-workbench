# 前端学习笔记 (Frontend Memos) - 2025-11-18

---

## Vue 3 响应式 API: `ref` 与 `reactive` 的对比与取舍

这是对 Vue 3 Composition API 中两个核心响应式工具的总结。

### `ref`

*   **核心思想**: 像一个“盒子”，可以把**任何类型**的数据（基本类型如 `string`, `number`，或对象类型如 `Array`, `Object`）装进去，使其整体具有响应性。
*   **用法**: 在 `<script>` 代码块中，必须通过 `.value` 属性来访问或修改“盒子”里的实际值。
*   **最佳适用场景**:
    1.  **处理基本类型**: 当你需要让单个的、独立的值（如数字、字符串、布尔值）变为响应式时，**只能用 `ref`**。
    2.  **需要重新赋值**: 当你可能需要将整个对象或数组完全替换成一个新的对象或数组时，`ref` 提供了这种灵活性（例如 `myRef.value = newArray`）。

### `reactive`

*   **核心思想**: 专门用于将一个**对象**或**数组**本身变为响应式。它会“解包”这个对象，使其内部所有嵌套的属性都具有响应性。
*   **用法**: 像操作普通 JavaScript 对象一样，直接访问和修改属性，**不需要 `.value`**。
*   **最佳适用场景**:
    1.  **组织相关数据**: 当你有一组逻辑上相关的属性（例如一个表单的状态、一个用户的个人资料），用 `reactive` 可以将它们组织在一个对象里，代码结构更清晰。
    2.  **简化访问**: 在操作对象内部的多个属性时，代码更简洁，因为它省去了到处写 `.value` 的麻烦。

### 决策建议与项目实例

一个简单的决策思路是：**“优先使用 `ref`。当你有一个包含多个相关属性的复杂对象，并且希望将它作为一个整体来管理时，再考虑使用 `reactive`。”**

在我们项目 `LoadSource.vue` 的代码中：

```javascript
const selection = reactive({
  dramaId: null,
  season: null,
  episode: null
})
```

这里使用 `reactive` 是一个非常合适的选择，因为它清晰地将 `dramaId`, `season`, `episode` 这三个紧密相关的状态“分组”到了一个名为 `selection` 的对象中，使得代码的意图更明确，访问也更直观 (`selection.dramaId`)。

---

## 面试题：`ref` 与 `reactive` 的区别

**这是否是一个常见的前端面试题？**

**是的，这是一个非常典型且高频的 Vue.js 面试题。**

面试官问这个问题，主要是为了考察你对 Vue 3 核心概念的理解深度，具体包括：

1.  **对响应式系统的理解**: 这是 Vue 3 Composition API 的基石。
2.  **对不同数据类型的处理**: 是否清楚 `ref` 的通用性和 `reactive` 的局限性（仅限对象）。
3.  **对 API 设计细节的掌握**: 是否知道 `.value` 的存在及其原因。
4.  **实际应用场景的判断**: 能否阐述在什么情况下应该用哪个，这体现了你的实践经验和代码品味。
5.  **对潜在问题的认知**: 是否了解 `reactive` 对象被重新赋值或解构时会丢失响应性的问题，以及如何使用 `toRefs` 来解决。

因此，在面试中，仅仅说出它们的定义是不够的，更重要的是能够结合场景，清晰地阐述“为什么”和“怎么用”。
